package main

import (
	"fmt"
	"gopkg.in/yaml.v3"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	//"github.com/tastybug/hookworm/internal/hookworm"
)

const (
	hookScriptContent = `#!/bin/sh
# Generated by hookworm
hookworm trigger
`

	configFile = ".hookworm.yml"
)

// Hook represents a single hook configuration from .hookworm.yml
type Hook struct {
	Name    string `yaml:"name"`
	Command string `yaml:"command"`
}

// HookPlay represents the structure of .hookworm.yml
type HookPlay struct {
	Hooks []Hook `yaml:"hooks"`
}

func main() {
	// Log the current working directory
	cwd, err := os.Getwd()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting current working directory: %v\n", err)
		os.Exit(1)
	}
	log.Printf("Current working directory: %s", cwd)

	// Check if a command is provided
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(1)
	}

	command := os.Args[1]

	switch command {
	case "install":
		if err := installHook(); err != nil {
			fmt.Fprintf(os.Stderr, "Error installing hook: %v\n", err)
			os.Exit(1)
		}
		fmt.Println("Hookworm installed successfully")
	case "dry-run":
		fmt.Println("Dry-run..")
		if err := executeHooks(); err != nil {
			fmt.Fprintf(os.Stderr, "Error running hooks: %v\n", err)
			os.Exit(1)
		}
	case "trigger":
		fmt.Println("Triggered....")
		if err := executeHooks(); err != nil {
			fmt.Fprintf(os.Stderr, "Error running hooks: %v\n", err)
			os.Exit(1)
		}
	default:
		printUsage()
		os.Exit(1)
	}
}

// installHook adds hookworm to the .git/hooks/pre-commit file
func installHook() error {
	// Find the .git directory
	gitDir, err := findGitDir()
	if err != nil {
		return fmt.Errorf("finding .git directory: %v", err)
	}

	// Define the hook file path
	hookPath := filepath.Join(gitDir, "hooks", "pre-commit")

	// Write the hook script
	err = os.WriteFile(hookPath, []byte(hookScriptContent), 0755)
	if err != nil {
		return fmt.Errorf("writing hook file: %v", err)
	}

	// Ensure the hook is executable
	err = os.Chmod(hookPath, 0755)
	if err != nil {
		return fmt.Errorf("setting hook permissions: %v", err)
	}

	return nil
}

// findGitDir locates the .git directory in the current or parent directories
func findGitDir() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		gitDir := filepath.Join(dir, ".git")
		if stat, err := os.Stat(gitDir); err == nil && stat.IsDir() {
			return gitDir, nil
		}

		// Move up one directory
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("no .git directory found")
		}
		dir = parent
	}
}

// HookExecutionError represents an error from a failed hook execution
type HookExecutionError struct {
	HookName string
	ExitCode int
}

func (e *HookExecutionError) Error() string {
	return fmt.Sprintf("hook %s failed with exit code %d", e.HookName, e.ExitCode)
}

// executeHooks loads and executes hooks from .hookworm.yaml
func executeHooks() error {
	config, err := loadPlay(configFile)
	if err != nil {
		return fmt.Errorf("loading config: %v", err)
	}

	for i, hook := range config.Hooks {
		log.Printf("Hook %d: Name=%s, Command=%s", i+1, hook.Name, hook.Command)

		// Execute the command
		cmd := exec.Command("sh", "-c", hook.Command)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		err := cmd.Run()

		// Check the exit code
		var exitCode int
		if err != nil {
			if exitErr, ok := err.(*exec.ExitError); ok {
				exitCode = exitErr.ExitCode()
			} else {
				return fmt.Errorf("executing hook %s: %v", hook.Name, err)
			}
		}

		log.Printf("Hook %s completed with exit code %d", hook.Name, exitCode)

		// Fail fast if exit code is non-zero
		if exitCode != 0 {
			return &HookExecutionError{
				HookName: hook.Name,
				ExitCode: exitCode,
			}
		}
	}

	return nil
}

// loadPlay reads and parses .hookworm.yml
func loadPlay(filePath string) (*HookPlay, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("reading %s: %v", filePath, err)
	}

	var config HookPlay
	err = yaml.Unmarshal(data, &config)
	if err != nil {
		return nil, fmt.Errorf("parsing %s: %v", filePath, err)
	}

	if len(config.Hooks) == 0 {
		log.Println("No hooks defined in .hookworm.yml")
	}

	return &config, nil
}

// printUsage displays the command-line usage
func printUsage() {
	fmt.Println("Usage: hookworm <command>")
	fmt.Println("Commands:")
	fmt.Println("  install  Install hookworm as a Git pre-commit hook")
	fmt.Println("  dry-run  Manually test the hookworm checks")
	fmt.Println("  trigger  Run the hookworm checks (called by Git pre-commit hook)")
}
